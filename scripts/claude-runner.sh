#!/bin/bash

# Claude Code Proë¥¼ ì‚¬ìš©í•˜ëŠ” ë¡œì»¬ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
# ì´ë¯¸ ë¡œê·¸ì¸ëœ Claude Code ì„¸ì…˜ì„ í™œìš©

set -e

echo "ğŸ¤– Claude Code Task Runner (using existing session)"
echo "================================================"

# Git ìµœì‹  ìƒíƒœ ê°€ì ¸ì˜¤ê¸° (remoteê°€ ìˆì„ ë•Œë§Œ)
if git remote -v | grep -q origin; then
    echo "ğŸ“¥ Pulling latest changes..."
    git pull origin main || true
else
    echo "ğŸ“¥ Working locally (no remote configured)"
fi

# tasks ë””ë ‰í† ë¦¬ì—ì„œ pending ì‘ì—… ì°¾ê¸°
TASK_DIR="tasks"
if [ ! -d "$TASK_DIR" ]; then
    echo "No tasks directory found. Waiting for tasks..."
    exit 0
fi

# pending ìƒíƒœì˜ ì‘ì—… ì°¾ê¸° (task-*.json ë˜ëŠ” *.json ëª¨ë‘ í™•ì¸)
for task_file in $TASK_DIR/*.json; do
    [ -e "$task_file" ] || continue
    
    # JSON íŒŒì‹± (jqê°€ ì—†ìœ¼ë©´ grep ì‚¬ìš©)
    if command -v jq &> /dev/null; then
        STATUS=$(jq -r '.status' "$task_file")
        TASK=$(jq -r '.task' "$task_file")
        ID=$(jq -r '.id' "$task_file")
        MACHINE=$(jq -r '.machine' "$task_file")
    else
        STATUS=$(grep -oP '"status":\s*"\K[^"]+' "$task_file" || echo "")
        TASK=$(grep -oP '"task":\s*"\K[^"]+' "$task_file" || echo "")
        ID=$(grep -oP '"id":\s*"\K[^"]+' "$task_file" || echo "")
        MACHINE=$(grep -oP '"machine":\s*"\K[^"]+' "$task_file" || echo "")
    fi
    
    # í˜„ì¬ ë¨¸ì‹ ìš© pending ì‘ì—…ë§Œ ì²˜ë¦¬ (hostname ë˜ëŠ” í™˜ê²½ë³€ìˆ˜ MACHINE_NAME ì‚¬ìš©)
    CURRENT_MACHINE="${MACHINE_NAME:-$(hostname)}"
    if [ "$STATUS" = "pending" ] && [ "$MACHINE" = "$CURRENT_MACHINE" ]; then
        echo "ğŸ“‹ Found task #$ID: $TASK"
        
        # ì‘ì—… ìƒíƒœë¥¼ in_progressë¡œ ë³€ê²½
        sed -i '' 's/"status": "pending"/"status": "in_progress"/' "$task_file"
        git add "$task_file"
        git commit -m "task: Start processing task #$ID"
        
        # remoteê°€ ìˆì„ ë•Œë§Œ push
        if git remote -v | grep -q origin; then
            git push
        fi
        
        # CLAUDE.md ì—…ë°ì´íŠ¸
        cat > CLAUDE.md << EOF
# Task #$ID

$TASK

## Guidelines
- Follow the development guidelines
- Write clean, maintainable code
- Add tests for new features
- Update documentation as needed
- Create meaningful commits
EOF
        
        # Claude Code ì‹¤í–‰ (ì´ë¯¸ ë¡œê·¸ì¸ëœ ì„¸ì…˜ ì‚¬ìš©)
        echo "ğŸš€ Running Claude Code..."
        
        # ê¶Œí•œ ìë™ ìŠ¹ì¸ ì˜µì…˜ìœ¼ë¡œ ì‹¤í–‰
        claude --dangerously-skip-permissions "$TASK" || true
        
        # ë³€ê²½ì‚¬í•­ ì»¤ë°‹
        if [ -n "$(git status --porcelain)" ]; then
            git add -A
            git commit -m "feat: Complete task #$ID - $TASK"
            
            # remoteê°€ ìˆì„ ë•Œë§Œ PR ìƒì„±
            if git remote -v | grep -q origin; then
                # PR ìƒì„±ì„ ìœ„í•œ ë¸Œëœì¹˜ ìƒì„±
                BRANCH_NAME="task-$ID-$(date +%s)"
                git checkout -b "$BRANCH_NAME"
                git push -u origin "$BRANCH_NAME"
            
                # GitHub CLIë¡œ PR ìƒì„± (ì„¤ì¹˜ë˜ì–´ ìˆë‹¤ë©´)
                if command -v gh &> /dev/null; then
                    gh pr create \
                        --title "[Task #$ID] $TASK" \
                        --body "## Automated task completion

**Task ID**: $ID
**Description**: $TASK
**Completed by**: Claude Code on $(hostname)

This PR was automatically generated by the local Claude Code runner.
Changes will be reviewed by Gemini." \
                        --label "automated,claude-code"
                fi
                
                git checkout main
            fi
        fi
        
        # ì‘ì—… ì™„ë£Œ í‘œì‹œ
        sed -i '' 's/"status": "in_progress"/"status": "completed"/' "$task_file"
        git add "$task_file"
        git commit -m "task: Complete task #$ID"
        
        # remoteê°€ ìˆì„ ë•Œë§Œ push
        if git remote -v | grep -q origin; then
            git push
        fi
        
        echo "âœ… Task #$ID completed!"
        
        # Gemini ë¦¬ë·° ìë™ ì‹¤í–‰
        echo "ğŸ” Running Gemini review..."
        # ìµœê·¼ ì»¤ë°‹ì—ì„œ ë³€ê²½ëœ ì½”ë“œ íŒŒì¼ ì°¾ê¸°
        CHANGED_FILES=$(git diff HEAD~1 --name-only 2>/dev/null | grep -E '\.(js|ts|jsx|tsx|py|go|java|cpp|c|rs)$' || true)
        
        if [ -z "$CHANGED_FILES" ]; then
            # HEAD~1ì´ ì—†ìœ¼ë©´ ì „ì²´ íŒŒì¼ í™•ì¸
            CHANGED_FILES=$(git ls-files | grep -E '\.(js|ts|jsx|tsx|py|go|java|cpp|c|rs)$' || true)
        fi
        
        if [ -n "$CHANGED_FILES" ]; then
            echo "Files to review: $CHANGED_FILES"
            export CHANGED_FILES
            # .env íŒŒì¼ì—ì„œ GEMINI_API_KEY ë¡œë“œ
            if [ -f ".env" ]; then
                export $(grep GEMINI_API_KEY .env | xargs)
            fi
            
            if [ -z "$GEMINI_API_KEY" ]; then
                echo "âš ï¸ GEMINI_API_KEY not found in .env file, skipping review..."
            else
                export GEMINI_API_KEY
                
                # í˜„ì¬ ìŠ¤í¬ë¦½íŠ¸ ë””ë ‰í† ë¦¬ ì°¾ê¸°
                SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
                PROJECT_ROOT="$( cd "$SCRIPT_DIR/.." && pwd )"
                
                # src/review.jsê°€ ìˆëŠ”ì§€ í™•ì¸
                REVIEW_SCRIPT="$PROJECT_ROOT/src/review.js"
                if [ -f "$REVIEW_SCRIPT" ]; then
                    cd "$PROJECT_ROOT"
                    node src/review.js || echo "âš ï¸ Review failed but continuing..."
                    cd - > /dev/null
                else
                    echo "âš ï¸ Review script not found at $REVIEW_SCRIPT"
                fi
            fi
            
            # ë¦¬ë·° ê²°ê³¼ê°€ ìˆìœ¼ë©´ ìë™ ê°œì„ 
            if [ -f "review-results.json" ] && [ -s "review-results.json" ]; then
                echo "ğŸ“ Processing review results..."
                
                # ë¦¬ë·° ë‚´ìš©ì„ íŒŒì¼ë¡œ ì €ì¥í•˜ì—¬ Claudeì— ì „ë‹¬
                REVIEW_CONTENT=$(cat review-results.json | python3 -c '
import json, sys
try:
    data = json.load(sys.stdin)
    if isinstance(data, list) and len(data) > 0:
        for item in data:
            comment = item.get("comment", "")
            path = item.get("path", "")
            # Extract nested JSON
            import re
            if "```json" in comment:
                json_match = re.search(r"```json\n(.+?)\n```", comment, re.DOTALL)
                if json_match:
                    nested_data = json.loads(json_match.group(1))
                    print(f"File: {path}")
                    for issue in nested_data[:5]:  # Top 5 issues
                        line = issue.get("line", "")
                        severity = issue.get("severity", "")
                        comment_text = issue.get("comment", "")
                        if severity in ["error", "warning"]:
                            print(f"  Line {line} [{severity}]: {comment_text[:100]}")
except Exception as e:
    pass
' 2>/dev/null || echo "")
                
                if [ -n "$REVIEW_CONTENT" ]; then
                    echo "Review feedback to apply:"
                    echo "$REVIEW_CONTENT"
                    
                    # ë¦¬ë·° ë‚´ìš©ì„ ì„ì‹œ íŒŒì¼ì— ì €ì¥
                    echo "$REVIEW_CONTENT" > review-feedback.txt
                    
                    # ë³€ê²½ëœ íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                    FILES_TO_IMPROVE=$(echo "$CHANGED_FILES" | head -1)
                    
                    # Claudeë¡œ ê°œì„  ì‹¤í–‰ - êµ¬ì²´ì ì¸ íŒŒì¼ê³¼ ë¦¬ë·° ë‚´ìš© ì „ë‹¬
                    if [ -n "$FILES_TO_IMPROVE" ]; then
                        echo "ğŸ”§ Applying improvements to $FILES_TO_IMPROVE..."
                        
                        # Claudeì—ê²Œ êµ¬ì²´ì ì¸ ê°œì„  ì§€ì‹œ
                        IMPROVEMENT_PROMPT="Based on this code review feedback, improve the file $FILES_TO_IMPROVE:

$(cat review-feedback.txt)

Focus on fixing errors and warnings. Keep the same functionality but improve code quality."
                        
                        claude --dangerously-skip-permissions "$IMPROVEMENT_PROMPT" || true
                        
                        # ê°œì„ ì‚¬í•­ ì»¤ë°‹
                        if [ -n "$(git status --porcelain)" ]; then
                            git add -A
                            git commit -m "refactor: Apply Gemini review improvements

Automatic improvements based on code review:
$REVIEW_CONTENT"
                            
                            # Push ê°œì„ ì‚¬í•­
                            if git remote -v | grep -q origin; then
                                git push
                            fi
                            
                            echo "âœ… Improvements applied and committed!"
                        else
                            echo "â„¹ï¸ No changes were made"
                        fi
                        
                        # ì„ì‹œ íŒŒì¼ ì‚­ì œ
                        rm -f review-feedback.txt
                    fi
                else
                    echo "â„¹ï¸ No actionable review feedback found"
                fi
            fi
        fi
        
        break  # í•œ ë²ˆì— í•˜ë‚˜ì˜ ì‘ì—…ë§Œ ì²˜ë¦¬
    fi
done

echo "ğŸ”„ Runner cycle complete"